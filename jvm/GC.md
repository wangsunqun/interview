# GC分类
JVM在进行GC时，可能针对三个区域进行垃圾回收分别是新生代、老年代、元空间，大部分时候回收的都是新生代。GC类型主要有以下四种类型。

### 新生代收集（Minor GC/Young GC）
* 只针对新生代的垃圾收集。<font color=red>**会STW**</font>
* 触发条件：eden区满
### 老年代收集（Major GC/Old GC）
    只针对 老年代的垃圾收集。 目前，只有CMS收集器会有单独收集老年代的行为。
### 混合收集（Mixed GC）
    指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。
### 整堆收集（Full GC）
    收集整个Java堆和元空间的垃圾收集。
    * 触发条件  
      1、如果老年代没有足够空间的话，那么就会进行一次 Full GC。  
      2、担保失败  
      3、system.gc()  
      4、持久代不足  
    * 担保机制（<font color=red>**默认开启**</font>）  
      * 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC

---

# 垃圾回收算法
### 标记清除算法
首先标记，然后把没标记的删除

### 复制算法
速度快，新生代，在这里发生GC叫Minor GC. 所有的Minor GC都会触发stop-the-world
把内存分为2块（新生代的s0、s1）。首先还是标记，然后当一块内存满了把标记的对象放到另一块，然后删除当前区域内存。

### 标记整理算法
老年代，在这里发生的GC叫Major GC
首先还是标记，然后在清除时候，把标记的对象都移到一端，然后清除边界（存活对象内存的边界）以外的部分。


---

# 垃圾回收器
![](../resources/gc.jpg)
（并行：多个线程一起GC，但是还是会卡住用户线程。并发：GC和用户线程会一起执行）
Serial/serial Old（串行）：单个线程，GC时候会停止用户线程，不是和任何服务器环境

Parallel/parallel（并行）：多个线程，GC时候会停止用户线程，用于大数据计算，注重吞吐量（代码运行时间=（总时间-GC时间）/总时间），与前台交互不多的后台计算。

parNew：多个线程，原理跟parallel差不多，但是这个适合追求低停顿的交互场景

Cms（并发，ConcMarkSweep）：GC与用户线程并发执行，适用于互联网环境，仅仅是在标记时候短暂STW，其余时间都是和用户线程并发执行。缺点：CPU压力大，有内存碎片（因为它使用标清算法）


G1：把堆内存分割成小块，并发的执行。
优点(也是回答了G1跟cms区别)：不会产生内存碎片，用户可以指定停顿时间（-XX:MaxGCPauseMillis）

垃圾收集器7个分4组：1 serial+serialold 2 parnew + cms 3 parallel + parallelold 4 G1
![](../resources/gc2.jpg)

---

# 可达性分析法
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。

### 可作为GCRoot对象
- 局部变量
- 静态变量、常量
- native方法引用的对象
