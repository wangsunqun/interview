# jmm(java内存模型)

## 指令重排

在执行程序时，为了提高性能，编译器和处理器（**CPU**）会对指令做重排序：

1. 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序（编译器重排）
2. 指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序（处理器重排）
3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行（处理器重排）

## 为了保证重排序不会对程序造成影响，必须遵守以下2个原则

### **as-if-serial**（单线程禁止重排序的规范）

as-if-serial是什么？   
不管编译器和处理器如何重排序，必须保证在单线程情况下程序的结果是正确的。他是一种规范，编译器，处理器都必须遵守。  
如果保证正确？  
编译器和处理器不会对存在数据依赖关系的操作做重排序

### **happen-before**（多线程禁止重排序的规范）

什么是happen-before？  
JVM会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。

Happens-Before规则：

1. 程序顺序规则：一个线程中的每个操作发生在该线程中的任意后续操作之前
2. 监视器（monitor）锁规则：对一个监视器的解锁操作发生在随后的加锁操作之前
3. volatile变量规则：对一个volatile变量的写发生在后续任意对这个变量的读操作之前
4. 传递性规则：如果A happens-before于B，B happens-before于C，那么A happens-before于C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

总结：一个操作“时间上的先发生”不代表这个操作先行发生；一个操作先行发生也不代表这个操作在时间上是先发生的（重排序的出现）。时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。

## volatile

**作用：**

1. 线程间可见：volatile并不是说线程直接读取主内存的值，而是当一个线程修改了工作内存的值，它会立即同步到主内存（没有用这个关键字并不是立即同步，而是看CPU），然后cpu总线嗅探机制会让其他核（线程)
   的工作内存里的值失效，这样就可以重新去主内存拉取最新值
2. 防止指令重排序

**原理：**  
内存屏障  
在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；所以volatile防止了指令的重排序(
保证有序性)和内存的一致性(保证可见性)  

**PS:用synchronized或者Lock给代码加锁，或者使用final，也是可以保证有序性与可见性的**  
1. 线程解锁前，必须把共享变量的最新值刷新到主内存中
2. 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值

### 内存屏障

作用：
1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

![](../resources/jmm.jpg)
主内存：内存条  
工作内存：cpu寄存器或者高速缓存

## 缓存一致性协议(MESI)  
MESI中每个缓存行都有四个状态，分别是E（exclusive）、M（modified）、S（shared）、I（invalid）  

## 总线嗅探机制
每个处理器（CPU）通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行读取、修改操作的时候，会重新从主内存中把数据读到处理器缓存中。

## 总线风暴

如果用了太多volatile，会不断嗅探（cas）总线导致总线带宽达到峰值。

## 伪共享：

这里一、二、三级缓存都是由缓存行组成，一个缓存行是64byte大小。伪共享的意思是，一个缓存行存多个属性，但是cpu都是以缓存行为单位执行的，这时候由于总线嗅探机制，会导致一个缓存行数据都失效，即使这个缓存行里只有一个属性有变化。解决方法：用@Contended注解，这个注解会自动为属性填充，使一个缓存行只有一个属性

PS: 寄存器和一级二级缓存都在cpu里，三级在外面  
![](../resources/jmm1.jpg)