# jmm(java内存模型)

## 硬件部分

![](../resources/jmm.jpg)
主内存：内存条  
工作内存：cpu寄存器或者高速缓存

![](../resources/jmm1.jpg)  
这里一、二、三级缓存都是由缓存行组成，一个缓存行是64byte大小。

## 伪共享

伪共享的意思是，一个缓存行存多个属性，但是cpu都是以缓存行为单位执行的，这时候由于总线嗅探机制，会导致一个缓存行数据都失效，即使这个缓存行里只有一个属性有变化。解决方法：用@Contended注解，这个注解会自动为属性填充，使一个缓存行只有一个属性

## volatile

**作用：**

1. 防止指令重排序（在volatile生成的指令序列前后插入内存屏障）
2. 线程间可见（内存屏障）

**PS:用synchronized或者Lock给代码加锁，或者使用final，也是可以保证有序性与可见性的**

1. 线程解锁前，必须把共享变量的最新值刷新到主内存中
2. 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值

## 内存屏障

作用：

1. 禁止指令重排序
2. 保证数据的可见性

## 指令重排

在执行程序时，为了提高性能，编译器和处理器（**CPU**）会对指令做重排序：

1. 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序（编译器重排）
2. 指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序（处理器重排）
3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行（处理器重排）

## 为了保证重排序不会对程序造成影响，必须遵守以下2个原则

### **as-if-serial**（单线程禁止重排序的规范）

as-if-serial是什么？   
不管编译器和处理器如何重排序，必须保证在单线程情况下程序的结果是正确的。他是一种规范，编译器，处理器都必须遵守。  
如果保证正确？  
编译器和处理器不会对存在数据依赖关系的操作做重排序

### **happen-before**（多线程禁止重排序的规范）

什么是happen-before？  
JVM会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。

Happens-Before规则：

1. 程序顺序规则：一个线程中的每个操作发生在该线程中的任意后续操作之前
2. 监视器（monitor）锁规则：对一个监视器的解锁操作发生在随后的加锁操作之前
3. volatile变量规则：对一个volatile变量的写发生在后续任意对这个变量的读操作之前
4. 传递性规则：如果A happens-before于B，B happens-before于C，那么A happens-before于C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

总结：一个操作“时间上的先发生”不代表这个操作先行发生；一个操作先行发生也不代表这个操作在时间上是先发生的（重排序的出现）。时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。

## 缓存一致性协议(MESI)

MESI中每个缓存行都有四个状态，分别是E（exclusive）、M（modified）、S（shared）、I（invalid） MESI只是一种协议，他需要借助总线嗅探机制来实现

原理：  
当CPU修改工作内存里的值的时候，会立即同步到主内存（****
）。如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，系统会发出信号通知其它CPU将该内存变量的缓存行设置为无效，当处理器对这个数据进行操作的时候，会重新从内存中把数据读取到处理器缓存中。

## 总线嗅探机制

其他CPU是怎么知道要将缓存更新为失效，是用到了**总线嗅探技术****。

每个CPU不断嗅探总线上传播的数据来检查自己缓存值是否过期了，如果处理器发现自己的缓存行对应的主内存被修改，就会将当前处理器的缓存行设置为无效状态

## 总线风暴

如果用了太多volatile，会不断嗅探（cas）总线导致总线带宽达到峰值。