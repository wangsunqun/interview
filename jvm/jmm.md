# jmm(java内存模型)

## 指令重排

在执行程序时，为了提高性能，编译器和处理器（**CPU**）会对指令做重排序：

1. 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序（编译器重排）
2. 指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序（处理器重排）
3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行（处理器重排）

## as-if-serial（单线程禁止重排序的规范）
as-if-serial是什么？  
不管编译器和处理器如何重排序，必须保证在单线程情况下程序的结果是正确的。他是一种规范，编译器，处理器都必须遵守。  
如果保证正确？  
编译器和处理器不会对存在数据依赖关系的操作做重排序

## happen-before（多线程禁止重排序的规范）

什么是happen-before？  
JVM会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。  

Happens-Before规则：  
1. 程序顺序规则：一个线程中的每个操作发生在该线程中的任意后续操作之前
2. 监视器（monitor）锁规则：对一个监视器的解锁操作发生在随后的加锁操作之前
3. volatile变量规则：对一个volatile变量的写发生在后续任意对这个变量的读操作之前
4. 传递性规则：如果A happens-before于B，B happens-before于C，那么A happens-before于C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

总结：一个操作“时间上的先发生”不代表这个操作先行发生；一个操作先行发生也不代表这个操作在时间上是先发生的（重排序的出现）。时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。

## volatile
作用：
1. 线程间可见：volatile并不是说线程直接读取主内存的值，而是当一个线程修改了工作内存的值，它会立即同步到主内存（没有用这个关键字并不是立即同步，而是看CPU），然后cpu总线嗅探机制会让其他核（线程)的工作内存里的值失效，这样就可以重新去主内存拉取最新值  
2. 防止指令重排序

原理：  
内存屏障

### 内存屏障


![](../resources/jmm.jpg)
主内存：内存条  
工作内存：cpu寄存器或者高速缓存  

## 嗅探机制工作原理

每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。

## 总线风暴

如果用了太多volatile，会不断嗅探（cas）总线导致总线带宽达到峰值。

## 伪共享：

这里一、二、三级缓存都是由缓存行组成，一个缓存行是64byte大小。伪共享的意思是，一个缓存行存多个属性，但是cpu都是以缓存行为单位执行的，这时候由于总线嗅探机制，会导致一个缓存行数据都失效，即使这个缓存行里只有一个属性有变化。解决方法：用@Contended注解，这个注解会自动为属性填充，使一个缓存行只有一个属性

PS: 寄存器和一级二级缓存都在cpu里，三级在外面  
![](../resources/jmm1.jpg)