## 位运算
## 1. <font color=blue>位运算</font>

- 计算机中数据都以二进制存储，其中整数占 4byte，即 32bit
- 5 的补码：0000 0000 0000 0000 0000 0000 0000 0101（最高位表示正负）
- 3 的补码：0000 0000 0000 0000 0000 0000 0000 0011

### 1.1. 位与（5 & 3）

- 规则：如果相对应位都是 1，则结果为 1，否则为 0
- 位与运算的结果：0000 0000 0000 0000 0000 0000 0000 0001，即 1，换成十进制为 1

### 1.2. 位或（5 | 3）

- 规则：如果相对应位都是 0，则结果为 0，否则为 1
- 位或运算的结果：0000 0000 0000 0000 0000 0000 0000 0111，即 111，换成十进制为 7

### 1.3. 位异或（5 ^ 3）

- 规则：如果相对应位值相同，则结果为 0，否则为 1
- 位异或运算的结果：0000 0000 0000 0000 0000 0000 0000 0110

### 1.4. 位非（ ~ 5）

- 规则：按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0
- 位非运算的结果：1111 1111 1111 1111 1111 1111 1111 1010，换成十进制为-6

### 1.5. 左移（5 << 2）

- 往左位移 2 位，得到 0000 0000 0000 0000 0000 0000 0001 0100，即 10100，换成十进制为 20
- 公式：a << b = a \* (2 ^ b)
- int 为 32bit，如果 int 左移超过 32 位，即等价于左移位数对 32 取模，long 类型也是如此，例如：1<<50=1<<18，1L<<65=1L<<1

### 1.6. 无符号左移（5 <<< 2）

- 往左位移 2 位，得到 0000 0000 0000 0000 0000 0000 0001 0100，即 10100，换成十进制为 20
- 与左移的区别：会连同符号位一起位移，而正常位移不会移动符号位

### 1.7. 右移（5 >> 2）

- 往右位移 2 位，得到 0000 0000 0000 0000 0000 0000 0000 0001，即 10100，换成十进制为 1
- 公式：a >> b = a / ( 2 ^ b )
- int 为 32bit，如果 int 右移超过 32 位，即等价于右移位数对 32 取模，long 类型也是如此，例如：1>>50=1>>18，1L>>65=1L>>1

### 1.8. 无符号右移（5 >>> 2）

- 往右位移 2 位，得到 0000 0000 0000 0000 0000 0000 0000 0001，即 10100，换成十进制为 1
- 与右移的区别：会连同符号位一起位移，而正常位移不会移动符号位

## 2. 基础数据类型

- byte/boolean 用 1 个字节来存储，char/short 用 2 个字节存储，float/int 用 4 个字节存储，double/long 用 8 个字节存储
- JVM 会缓存部分基础封装类型的值，Byte, Short, Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 以外，这个范围都不能改变

### 2.1. Integer

- Integer 在 JVM 中只会缓存-128-127，其余的都不会缓存，不能用==判断相等
- 由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以 float 和 double 会丢失精度

### 2.2. String

- String 对象无法被修改，String 类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象（会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的 string 对象被创建出来）
- 如果需要修改字符串，应该使用 StringBuffer 或者 StringBuilder
- StringBuilder 内部使用可变字符数组（char[] ），初始字符数组容量为 16，存在扩容，其 append 拼接字符串方法内部调用 System 的 native 方法，进行数组的拷贝，不会重新生成新的 StringBuilder 对象
- StringBuilder 扩容的大小是新字符串的长度的 2 倍+2（+2 是考虑到 append()之后可能会加分隔符，而 char 在 java 中占 2 个字节）
- StringBuilder 每次调用 toString 方法而重新生成的 String 对象，不会共享 StringBuilder 对象内部的 char[]，会进行一次 char[]的 copy 操作（非线程安全）
- jdk6 中 subString 时，不会创建新的字符串，而是引用旧的字符串的字符数组，只是改变了 offset 和 count，如果字符串比较大，导致字符数组一直无法释放，造成内存浪费，如果一直执行 subString，会造成内存泄露，jdk7 中会先将字符数组 copy 一份，然后再截取
- **拼接字符串方法：+、string.concat、StringBuffer、StringBuilder、StringUtils.join、String.join（jdk8）**
    - +会被编译成 new StringBuilder，但是在循环里会不断创建stringbuilder对象，所以非循环情况下用+合适
    - concat 每次都会创建新的 String，不推荐使用
    - join 方法都是通过 StringBuilder 来实现的
    - 速度比较：StringBuilder>StringBuffer>StringUtils.join>concat>+**
- StringBuilder 和 StringBuffer 的区别：都是使用字符数组和 count，动态扩展字符数组，但是 StringBuffer 是线程安全的，因为 append/toString 等方法声明了 synchronized

## 3. switch

- switch 支持的数据类型：byte short int char String
- jdk7 中 switch 对 char 的支持
  - 实际上比较的是 ascii 码，编译器会把 char 型变量转换成对应的 int 型变量
- jdk7 中 switch 对 String 的支持
  - 通过 equals()和 hashCode()方法来实现，switch 中比较的是 hashcode，但是因为 hashcode 可能会变，所以在每个 case 中会再用 equals 比较一次字符串的值
- switch 对枚举的支持
  - 实际上比较的是枚举的 ordinal（序号，整数类型）
- char+int 或者 char+char 会的到一个整数，而不是 String，因为 char 相加，实际上加的是 char 的 ascii 值
- == 和 equals 的区别：
  - == 的作用：
    - 基本类型：比较的是值是否相同
    - 引用类型：比较的是引用是否相同
  - equals 方法取决于具体实现
  - 示例：
    ```java
    String x = "string";
    String y = "string";
    String z = new String("string");
    System.out.println(x==y); // true
    System.out.println(x==z); // false
    System.out.println(x.equals(y)); // true
    ```
- JDK12 开始有 switch 表达式
