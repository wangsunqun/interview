synchronized同步的意思synchronized: 对象级别。例如：一个类有2个方法，两个方法都上锁，因为是对象级别，即使2个线程访问不同方法，一个方法没有释放锁另一个也不能执行，这就是同步。除非另一个方法没上锁，那么改方法就是异步的。一个对象一把锁：synchronized，对象锁，只对一个对象生效！static synchronized: 就是类级别的锁。如果一个方法获得锁，那么该类下所有被static sychonizerd修饰的方法都会阻塞。即使你new了多个实例也不行，因为static只有一份。类锁和对象锁区别：一但一个方法获得锁都会导致其他方法阻塞。但是多线程new了多个对象，则对象锁不会阻塞。如果方法内有异常，那么锁立即释放。锁重入：比如2个方法a、b都加了synchronized，a里调用了b，那么可以执行b方法（即使a没有执行完）。继承也可以用锁重入。mark word对象是由对象实例和对象头组成，对象头包括markword和类型指针，如果是数组，还包括数组长度，markword里头记录了各种对象信息(锁信息、GC分代年龄、hashcode、monitor指针等)synchronized原理：对象头有个mark word，指向monitor。monitorenter ： 每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：　　1.如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。　　2.如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.　　3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。monitorexit：　　这段话的大概意思为：　　执行monitorexit的线程必须是objectref所对应的monitor的所有者。　　指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。1、通过CAS尝试把monitor的_owner字段设置为当前线程2、如果线程该线程已经占有该monitor，只是重新进入，_recursions（重入锁计数）加13、当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程4、如果调用wait，那么释放_owner和_recursions - 1，把当前线程放入 _WaitSet队列里5、如果调用notify，那么从队列里唤醒synchronized同步块和同步方法区别：1、同步块，在块前后会插入monitorenter和monitorexit，这两个命令分别执行上述的+1 -1操作2、同步方法，每个方法有个标识（flag），这个flag会多一个标识 ACC_SYCHRONIZED，JVM通过这个标识就知道这个是一个同步方法，进而执行上述的 +1 -1操作。synchronized状态：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。也是用cas实现的。自适应自旋锁： 会根据前一次在同一个锁上得自旋时间及锁得拥有者状态来决定锁消除：jvm会在编译时候，去除没有必要多余的锁，提升代码效率锁粗化：比如循环里有上锁 解锁操作，jvm会粗话到循环外偏向锁：如果一个锁只有一个线程用到，并不存在竞争关系，那么mark word会记录下来当前线程id，下次这个线程再来的时候就直接运行方法不做锁操作，在markword里记录轻量级锁：轻量级锁是由偏向锁升级而来，当偏向锁运行一个线程进入同步块时候，第二个加入锁竞争，偏向锁就会升级为轻量级锁，它不会阻塞，而是自旋。（自旋几次还没获取到锁升级为重量级锁）,用cas实现自旋锁重量级锁：内核会从用户态转为内核态，用monitor//=======================================================================================================//LockSupport原理通过调用 Unsafe 的 park 和 unpark（CAS 操作）对线程进行阻塞/放行操作底层 park 和 unpark 的原理：int _count = 0; //初始值是0void park(){//说明有人调用过unpark，本次park不阻塞 // 这个操作主要是用于LockSupport 支持先unpark。如果先unpark，那么park不会阻塞if(_count>0){_count=0return;}block()}void unPark(){//说明有人park，唤醒它if(_count<1){unblock()}_count=1}//=======================================================================================================//StampedLock解决问题（饥饿问题）：虽然ReentrantReadWriteLock有读写锁模式，但是当读并发很高时候，写基本上没法进行StampedLock控制锁有三种模式（写，读，乐观读）（1）读、写。都属于悲观锁，跟reentrantlock一样（2）乐观读取（Optimistic Reading）：提供了tryOptimisticRead方法返回一个非0的stamp，只有当前同步状态没有被写模式所占有是才能获取到。乐观锁读主要解决饥饿问题，原来的悲观锁模式，读并发高时候，往往写不了，但是用了乐观锁，能大大降低悲观写的阻塞。---CountDownLatch（倒数计数器）介绍地址
* CountDownLatch 基于 AQS 实现，允许一个或者多个线程一直等待，直到一组其它操作执行完成，采用 AQS 的共享模式实现，await 时执行 CAS 后加入到同步队列并执行 LockSupport 的 park，countDown 时执行 CAS，直到 state=0 时执行 LockSupport 的 unpark 方法
* 需要指定一个整数值，此值是线程将要等待的操作数。当某个线程为了要执行这些操作而等待时，需要调用 await 方法。await 方法让线程进入休眠状态直到所有等待的操作完成为止。当等待的某个操作执行完成，它使用 countDown 方法来减少 CountDownLatch 类的内部计数器。当内部计数器递减为 0 时，CountDownLatch 会唤醒所有调用 await 方法而休眠的线程们

---
CyclicBarrier（循环屏障）介绍地址
* CyclicBarrier 基于 ReentrantLock的condition实现，控制多个线程执行自有操作后一直等待，所有的线程必须等待对方，直到所有的线程到达屏障，然后继续运行，是用来协同多线程一起工作的
* CyclicBarrier 维护了一个 count，表示总线程数，调用 dowait 方法时，先将 count 减一，使用 ReentrantLock 确保 count 的计数准确，再判断 count=0
* 如果 count=0，signalAll所有线程，并重新初始化循环屏障（所以 CyclicBarrier 可以重用）
* 如果 count 不等于 0，await进行等待

---
Phaser（阶段）介绍地址 1介绍地址 2Phaser 是 JDK 7 新增的一个同步辅助类，它可以实现 CyclicBarrier 和 CountDownLatch 类似的功能，而且它支持对任务的动态调整，并支持分层结构来实现多线程多阶段执行---Semaphore（信号量）介绍地址 1介绍地址 2
* 基于 AQS 实现，用 state 来保存信号量的令牌数。tryRelease 会增加令牌数，acquireShared 会减少令牌数，有公平策略和非公平策略两种实现方式

---
Exchanger（线程数据交换器）
* Exchanger 用于两个线程之间的数据交换（只能同步两个线程）。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过 exchange()方法交换数据，当一个线程先执行 exchange()方法后，它会一直等待第二个线程也执行 exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了
* 在 JDK5 中 Exchanger 被设计成一个容量为 1 的容器，存放一个等待线程，直到有另外线程到来就会发生数据交换，然后清空容器，等到下一个到来的线程
* 从 JDK6 开始，Exchanger 用了类似 ConcurrentMap 的分段思想，提供了多个 slot，增加了并发执行时的吞吐量

使用案例：public class Test {static class Producer extends Thread {private Exchanger<Integer> exchanger;private static int data = 0;Producer(String name, Exchanger<Integer> exchanger) {super("Producer-" + name);this.exchanger = exchanger;}@Overridepublic void run() {for (int i=1; i<5; i++) {try {TimeUnit.SECONDS.sleep(1);data = i;System.out.println(getName()+" 交换前:" + data);data = exchanger.exchange(data);System.out.println(getName()+" 交换后:" + data);} catch (InterruptedException e) {e.printStackTrace();}}}}static class Consumer extends Thread {private Exchanger<Integer> exchanger;private static int data = 0;Consumer(String name, Exchanger<Integer> exchanger) {super("Consumer-" + name);this.exchanger = exchanger;}@Overridepublic void run() {while (true) {data = 0;System.out.println(getName()+" 交换前:" + data);try {TimeUnit.SECONDS.sleep(1);data = exchanger.exchange(data);} catch (InterruptedException e) {e.printStackTrace();}System.out.println(getName()+" 交换后:" + data);}}}public static void main(String[] args) throws InterruptedException {Exchanger<Integer> exchanger = new Exchanger<Integer>();new Producer("", exchanger).start();new Consumer("", exchanger).start();TimeUnit.SECONDS.sleep(7);System.exit(-1);}}输出结果：Consumer- 交换前:0Producer- 交换前:1Consumer- 交换后:1Consumer- 交换前:0Producer- 交换后:0Producer- 交换前:2Producer- 交换后:0Consumer- 交换后:2Consumer- 交换前:0Producer- 交换前:3Producer- 交换后:0Consumer- 交换后:3Consumer- 交换前:0Producer- 交换前:4Producer- 交换后:0Consumer- 交换后:4Consumer- 交换前:0//=======================================================================================================//reentrantlock公平锁：这个是reentrantlock才有的，Lock lock = new ReentrantLock(true);  意思是把锁给等待时间最久的线程。（理解意思就好，慎用）lock原理： cas+aqs。以上锁为例，他跟synchronized一样有个valatile的state，利用cas进行加减，当另一个线程获取到state!=0那么进入aqs的队列。LOCK:1、重入锁reentrantlock（基本跟synchronized一样）；        Lock lock = new ReentrantLock();          public void A(){              lock.lock();              try{                    ...               }catch(){              }finally{                   lock.unlock();               }          } 2、condition          Lock lock = new ReentrantLock();          Condition condition = lock.newCondition();          public void A(){              lock.lock();              try{                    ...                     condition.await();      //相当于     Object的wait();                    condition.signal();      //相当于     Object的notify();                    condition.signalAll();      //相当于     Object的notifyAll();  唤醒所有使用该condition的线程              }catch(){              }finally{                   lock.unlock();               }          } 3、读写锁：reentrantreadwritelock          ReenTrantReadWriteLock rwLock = new ReenTrantReadWriteLock();          ReadLock readLock = rwLock.readLock();          WriteLock write Lock = rwLock.writeLock();读写锁意思就是：读读共享，读写互斥，写写互斥。意思是如果两个方法都是调用读锁，那么多线程可以并发访问。但是一个方法调用读方法，一个调用写方法，那么该锁就会变成同步锁（一个方法完了才去执行另一个）。多线程的异常：某个线程的异常只会在那个线程抛出并结束该线程，不会影响到其他线程。但是如果想在出异常时候停下来，那就抛出一个运行时异常多线程间通信：wait（立即释放）和notify   区别：    ①synchronized和lock区别：synchronized是关键字，lock是一个工具集合    ②sleep和wait区别：sleep让出cpu但是不释放锁，wait释放cpu和锁（wait要配合synchronized使用）    ③wait和await区别：notifyall无法控制唤醒wait的执行顺序，但是lock可以new多个condition，也就是说可以用condition唤醒你要唤醒的awaitThread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别Thread.sleep()和 Object.wait()的区别
* Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁
* Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去
* Thread.sleep()到时间了会自动唤醒，然后继续执行
* Object.wait()不带时间的，需要另一个线程使用 Object.notify()唤醒
* Object.wait()带时间的，假如没有被 notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁

Thread.sleep()和 Condition.await()的区别
* Object.wait()和 Condition.await()的原理是基本一致的，不同的是 Condition.await()底层是调用 LockSupport.park()来实现阻塞当前线程的

Thread.sleep()和 LockSupport.park()的区别
* 从功能上来说，Thread.sleep()和 LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源； Thread.sleep()没法从外部唤醒，只能自己醒过来
* LockSupport.park()方法可以被另一个线程调用 LockSupport.unpark()方法唤醒
* Thread.sleep()方法声明上抛出了 InterruptedException 中断异常，所以调用者需要捕获这个异常或者再抛出； LockSupport.park()方法不需要捕获中断异常
* Thread.sleep()本身就是一个 native 方法； LockSupport.park()底层是调用的 Unsafe 的 native 方法

Object.wait()和 LockSupport.park()的区别
* Object.wait()方法需要在 synchronized 块中执行； LockSupport.park()可以在任意地方执行
* Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出
* LockSupport.park()不需要捕获中断异常
* Object.wait()不带超时的，需要另一个线程执行 notify()来唤醒，但不一定继续执行后续内容
* LockSupport.park()不带超时的，需要另一个线程执行 unpark()来唤醒，一定会继续执行后续内容
* 如果在 wait()之前执行了 notify()会怎样? 抛出 IllegalMonitorStateException 异常
* 如果在 park()之前执行了 unpark()会怎样? 线程不会被阻塞，直接跳过 park()，继续执行后续内容