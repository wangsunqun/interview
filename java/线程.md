## 线程状态
![](../resources/threadstatus.jpg)
1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
   线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. 阻塞(BLOCKED)：表示线程阻塞于锁。
4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕

---

## 线程池
### jdk提供的线程池
1. newFixedThreadPool(coun t)：定长线程池，最多可同时执行 count 个任务，线程池的线程数量达 corePoolSize 后，即使线程池没有可执行任务时，也不会释放线程，具体实现为 new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())，因此，工作队列为无界队列，导致 maximumPoolSize 和 keepAliveTime 以及 handler 将会是个无用参数，且永远不会执行拒绝策略
2. newSingleThreadExecutor：只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，由于使用了无界队列，所以也不会执行拒绝策略
3. newCachedThreadPool：实现为 new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue())，最大线程数可达到 Integer.MAX_VALUE，即 2147483647

### 线程池参数
int corePoolSize：核心线程数
int maximumPoolSize：最大线程数
long keepAliveTime：空闲线程存活时间（空闲线程：大于核心线程数的那些线程，没任务时候还存活多久）
TimeUnit unit：空闲线程存活时间单位
BlockingQueue<Runnable> workQueue：阻塞队列
ThreadFactory threadFactory：线程工厂，可以设置线程名字，线程错误捕获等
RejectedExecutionHandler handler：拒绝策略

### 拒绝策略
CallerRunsPolicy：用主线程执行
AbortPolicy：默认，直接抛错
DiscardPolicy：直接丢弃，不抛错
DiscardOldestPolicy：丢弃最早的任务，然后执行

### 线程池允许原理
1. 线程池首先当前运行的线程数量是否少于 corePoolSize，如果少于，则创建新线程来执行任务
2. 当线程数达到 corePoolSize 后，后续的任务（Runnable）将放入 workQueue
3. 当 workQueue 也满了之后，则继续开启新线程执行任务，直到总线程数达到 maximumPoolSize 为止
4. 当总线程数达到 maximumPoolSize，之后再有新的任务，则交给拒绝策略（RejectedExecutionHandler）来处理

### 自定义线程池
```
// 仅仅是举例，这个线程池在线程用完后阻塞到有线程为止
public static ThreadPoolExecutor activeExecutor = new ThreadPoolExecutor(20, 40, 100,
    TimeUnit.MILLISECONDS, new SynchronousQueue<>(), Executors.defaultThreadFactory(), (r, executor) -> {
        try {
            executor.getQueue().put(r);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
});
```

### 关闭线程池
1. shutdown：将线程池里的线程状态设置成 SHUTDOWN 状态, 然后中断所有没有正在执行任务的线程
2. shutdownNow：将线程池里的线程状态设置成 STOP 状态, 然后停止所有正在执行或暂停任务的线程
3. 只要调用这两个关闭方法中的任意一个, isShutDown() 返回 true， 当所有任务都成功关闭了, isTerminated()返回 true

### 延时定时任务线程池
```
ScheduledExecutorService service = Executors.newScheduledThreadPool(num);
延时执行：
//延时n秒执行
service.schedule(Runnable, n, TimeUnit.SECONDS);
service.schedule(Callable, n, TimeUnit.SECONDS);
循环执行：
//循环执行任务，首先延时m秒执行，n秒循环一次
service.scheduleAtFixedRate(Runnable, m, n, TimeUnit.SECONDS);
```

### 延时定时任务Timer
```
public class M {
public static void main(String[] args) {
   Timer timer = new Timer();
   timer.schedule(new MyTask(), 1000, 2000);
}

class MyTask extends TimerTask {
   @Override
   public void run() {
      System.out.println("dddd");
   }
}
```

### 创建线程5种方式
1. 一个类法继承Thread，然后在main里实例化该方法，并执行start
2. 一个类实现Runnable，然后在main里实例化Thread线程（类的对象放里头），并执行start。
3. 一个普通类，然后在main里实例化Thread线程（Thread tt = new (new Runable(){重写run方法})）
4. 使用Excutor，exec.execute(new 一个实现Runnable的类 )
5. 使用Excutor，exec.execute(new Runnable(){} 

### 注意易错点
这个部分大多为本人工作中的经验教训
1. 线程池里包括线程不会将异常抛到外面，进而无法打印。他会打印工作台但是不会被线程池外面的trycatch捕获，这点我查了很多资料都不完美，所以要养成线程里操作都用trycatch裹起来的习惯
2. 线程抛错，那么该线程就死了，线程池会重新创建。之前有个redis分布式锁的工具类value用到了线程id，这样就无法删除锁了

---

## 